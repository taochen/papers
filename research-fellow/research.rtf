{\rtf1\ansi\ansicpg1252\cocoartf1138\cocoasubrtf510
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fmodern\fcharset0 Courier;}
{\colortbl;\red255\green255\blue255;\red217\green11\blue0;\red77\green77\blue77;\red128\green128\blue128;
\red154\green154\blue154;\red103\green29\blue0;\red179\green179\blue179;\red164\green8\blue0;\red110\green5\blue0;
\red63\green105\blue30;\red69\green39\blue0;\red73\green0\blue0;\red205\green205\blue205;\red230\green230\blue230;
\red217\green234\blue202;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid101\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid2}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural

\f0\fs24 \cf0 1. tasks, deadline for the DAASE project? need hyper he rustics?\
\
no task, no deadline,  hyper heristic\
\
2. what direction? optimisation on software architecture, can we do in the context of self-adaptive systems and cloud computing?\
\
yes we can do this, can do on domain of self-adaptive system and cloud computing.\
\
\
3. how we can get company involve?\
\
a. company give us data, we run experiments/evaluations\
b. we delivery algorithms/tool to company for their daily software development/maintainace, we analyse the result in the end by e.g., interview.\
\
both are OK\
\
4. build a software/tool for the algorithm? \
\
for case study\
\
\
TODO\
\
problems, research questions, significance of the problem and possible solutions (runtime optimisation for self-adaptive software architecture)\
1. when to trigger the optimisation during adaptation\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural

\b \cf0 Research questions:\
\
1) how to choose the features.\
2) how to ue technical debt to make reasoning\
3) if need ensemble or concept drift
\b0 \
\
a. technical debt to represent the long-term and short-term of decision.\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural
\cf2 b. multiple feedbacks, e.g., coming from human, and coming from the adaptable software, the direction stage. Classify the users and then see of trigger adaptation coresspondly. \cf0 \
\
2. resilient optimisation with respect to the constraints given by stakeholders. (or the other is try to find the range of constraints that can be stable, using dynamic technical debt) the result of too good or too bad requirement should be at least similar to the result of an rational requirement.\
\
Mitigating the effects of requirements uncertainty: xxxx optimisation for self-adaptive software architecture\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural

\b \cf0 Research questions:\
\
1) how to do multi objective optimisation for SAS architecture with mixed variables (inside knee v.s. outside knee)\
2) whether introducing constraints can tune multi objective optimisation (inside requirements v.s. outside requirements)\
3) how to mitigate requirement uncertainty\
     a. how to formulate the problem with requirements and their mitigation.\
     b. how to design multi objective optimisation that can consider requirements.\
     c. how is the resilience of the algorithm to requirements uncertainty.\
4) how to incorporate dynamics into the problem.
\b0 \
\
======================\
feature guided and knee point focused multi-objective optimisation for self-adapting software architecture at runtime (we do not use FM as qos model and thus do not assume the effects of decision on goals!) FEMOSSA\
\
we can say the QoS model is also guided by the gene, which is a result of feature model. But it needs to additional consider environmental variables.\
\
if aim for fewer gene, which can lead to less computation effort in fitness evaluation. Also easier to be maintained. This aims to include only the feature, which has more than one optional value, so that they are only useful in evolution. This can distinguish us from classic 0/1 gene translation.\
\
we also want to project dependency to mutation and crossover separately. \
\
We can assume the given FM is correct, i.e., no dead feature, e.g., those that has both required/excluded on the same main.\
\
dependency: the optional range of one feature depends on the chosen value of others.\
\
CHALLENGE\
\
\
\
1. how to perform optimisation with large search space at SAS runtime.\
 search-based algorithm, particularly EA, has been popular as exact solution does not scale, this raises: how to systematically and automatically model the problem to EA\
\
2. how to reason about trade-off in decision.\
\
3. how to find a knee point.\
\
LIMITATION\
\
1. exact methods are easily adopt and they are design to handle dependency constraint, but they do not scale well. Other existing work rely on manual analysis and translation to EA, they do not consider dependency between features, as EA is not naturally design to handle dependency constraints., Althgouht some objective function (e.g., ML) one can distinguish valid/invlaid ones, letting the EA explore the entire search space would still waste evaluation and not prevent invalid solution in final population (affect optimisation quality). Whats worse, the solution may need to be corrected if no valid ones found, this might destroy the evolution history.\
\
FM has been used for the problem this help to systemically model control features and their dependency, some work has also marriage FM and EA, but they have further limitations when translate into EA thus cannot be used for our SAS problem at runtime:\
\
1. does not consider numeric feature explicitly.\
\
2. only consider categorical feature not numeric feature in the encoding of individual. If use the categorical encoding (0/1) to numeric that could rise more computational effort and harder the handle dependency. \
\
3. FM work also consider dependency, but do not explicitly  consider complex dependency, especially numeric ones, within the EA and search process to prevent violation, as EA is not naturally design to handle dependency constraints. Instead, they use dependency as an objective, which can find more valid solution but is still not completely resolve the problem and it is not suitable for SAS runtime as it introduces extra complexity.\
\
4. Weighted sum is limited as it is difficult to specify weights.To explore trade-off, some work use multi-objective optimisation.  But they rely on NSGA2, which is limited in diversity in finding trade-off decisions and thus the quality of decision\
\
5. knee point. No other has considered. Might lead to unbalanced decisions, which is normally not preferred.\
\
CONTRIBUTIONS:\
\
We use FM to express the SAS problem, then systematic and automatic translation of the problem FM in EA context.\
\
0. we consider numeric features and their dependency.\
\
1. automatically create new representation/encoding with reduced gene in EA from FM. (lower overhead and help to handle dependency)\
\
2. automatically extract dependency , based on the new representation of gene from FM, and inject them into mutation and crossover. (reduced search space so save function evaluation cycles for unwanted space, prevent invalid decisions, improve optimisation quality)\
\
1-2 also are win-win situation.\
\
3. MOEAD STM\
\
4 knee points.\
\

\b manual steps:\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural

\b0 \cf0 \
\
1. add numeric attributes and complex numeric dependency based on the scenario. (such dependency can be changed back to classic excluded)\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural
\cf2 numeric feature is the one that has more than one predefined and alternative children which have attributes of numeric value, and it has not other type of children. The children are regarded as categorical. (they have large children and can be used for mathematical comparison in dependency)\
\
if a feature A has numeric value but only one XOR children or not XOR, then than can only be considered as categorical, they are usually consider as MAN features. In case of dependency to numeric feature,  we simply restrict the range of the dependent numeric feature.\
\
all children range should be given, including 0. If the feature has 0 but with a core (no conditionally switch off), or with core (no conditionally switch off) but not 0, then it is false option design error.\cf0 \
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural

\b \cf0 automatic steps:
\b0 \
\
\
\
grow\
(parent = branch)\
\
0. Add numeric feature to a leaf. (no need as this is presented at the beginning )\
\
1. add switch on/off sub-feature to leaf which share OR operation\cf3  and has no children\cf0 . \cf4  and already has children\cf0 . \
\
2. add on to leaf whose do not share OR or ALT \cf5 and has no children\cf0 . \
\
\
\
3. add switch off, if optional and if the node is parent, then itself and its sub-parent need to add new sub-feauture repenting switch off. \
\
4. Add off to parent which share OR and ALT operation and to all its sub parents. \
\
\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural
\cf6 If we find a numeric feature that needs to be switch has no 0, or if the numeric feature has 0 but there is no way for it to switch off, then it is a design error (false option as some feature can be switch off but no such option).\cf0 \
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural
\cf4 5. add on to parent that is required by a cross dependency and do not have more than one ALT.\
(this can prevent complication when it only has OR children and it is optional)\cf0 \
\
prune \
\
1. remove parent who has less than one alternative leaf child (feature has no variability)\
2. link dependency to all children parents, if any. If no children, ensure that the dependency is always true.\
3. in-branch dependency would be inherited for the ones that has not been removed.\
\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural

\b \cf0 rule2:
\b0  \
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural
\cf2 feature model: branch feature with more than on ALT is gene, direct children as optional values which are mutual excluded. We then prune the other non-gene branch. (leaf is still in consideration but just not as gene)\cf7 Because i) they help to translate some leaf feature into selection as they can be considered as values ii) they cannot  be disregard as gene without affecting variability, causing some solution can not be explored. iii) Removing them can also affect adaptation and the design of actuators, as they cannot select as a constant  at design time and the solution would have not contained them.  \
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural
\cf8 Those branches can be pruned because they only have on (where do not have variability), on/off variability and by adding proper on/off XOR leaf our add rules ensure that their variability can be represented by their children.\
\
Because if it cannot turn on, it means none of its children can be selected, which means a design error.\
if it allow to turn off and cannot turn off, it means not all of its children can be deselected , which violate our rule. \cf7 \
\
Therefore, for those feature that removed, if they have actuators then we should only have on/off option, and they are fixed to on in the actual configurations and excluded from runtime adaptation (for XOR, we won't have only 0/1 for a branch, because this is the same as optional)\
\
The sensor/acuator of the gene are the ones that only will be triggered at runtime.\
\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural
\cf0 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural
\cf8 Since we prune some branches, we then need to restructure dependency for the pruned branch to preserve variability. \
\
Wothnting that our goal is not to find the min number gene, but to see a reduced number of gene than 0/1 representation, which is more suitable for SAS. in fact if xOR parent has all children as XOR parent, their variability can also be represented by its children, but this need much complex restructing of dependency for reducing only 1 gene.\cf0 \
\
\
then design sensor/acautor for each gene.\
\
once the genes are identified, we then can translate the dependency based on each gene.\
\
\
This will help to selected only the necessary features, as some features cannot be changed at runtime or they are duplicated and can be represented by some other features. Thus not even needed to be considered in the modelling.\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural

\b \cf0 rule3:
\b0   (extract dependency chain)\
\
DEPENDENCY\
\
numeric feature is only numeric, i.e., usually leaf, but it can have categorical dependency (CTC)\
categorical feature can only have categorical dependency\
\
(range-to-existence and existence-to-range are different under required! the former when non-exist the range cannot be selected, while the later can)\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural
\cf8 Range != to full range, as this would be the same as categorical, and this would be design error.\cf0 \
range = mathmatical constraint, e.g, =0 or >= 50 or\'85\
\
\
manual=explicit, otherwise implicit\
\
required\
\
categorical-required:  existence-to-existence (manual), selection-to-existence, existence-to-selection, selection-to-selection (in-branch or CTC)\
numeric-required (manual, \cf9 use exclude when translate into classic FM, can not be used with leaf feature\cf0 ): althematic, range-to-range, existence-to-range, range-to-existence, selection-to-range, range-to-selection. (CTC)\
\
\
excluded (only consider one way)\
\
categorical-excluded:  existence-to-existence (manual), selection-to-existence, existence-to-selection, selection-to-selection (CTC)\
numeric-excluded (manual, \cf9 use exclude when translate into classic FM, can not be used with leaf feature\cf0 ): althematic, range-to-range, existence-to-range, range-to-existence, selection-to-range, range-to-selection. (CTC)\
\
at-least-one-required (auto-convert CTC) to categorical OR group: existence-to-existence , existence-to-selection, existence-to-range\
\
at-least-one-exist  (auto-convert in-branch) within OR group (this is a weak dependency as it could be ensured by other siblings)\
\
no at-least-one-excluded as if the OR member is dependent then can be simply see on each one in isolation, and finally intersect. (might be do not have to mention this)\
\
more complex, e.g, conditional numeric dependency can be easily added.\
\
(\cf8 we do not have XOR which is represented by features, required and excluded cannot be placed on sty that can not be switch off. And no conradiction between features so to avoid closed loop dependency)\cf0 \
========\
\
-in branch dependency \
\
For each gene only:\
\
\
=============\
\
3 important notions:\
\
1.  those closest descendant genes $G$ of $F$, which follow each path from $F$ (vertical and horizontal)\
2. if $G$ has Mandatory relation to its parent and the path between $F$ and $G$ does not contain deselectable features  (vertical)\
3. $P$ is not a gene, and that there is no gene on the path from $P$ to $F$  (vertical (for OR) and horizontal) (for vertical OR, this can be change to if and acsent features are gene)\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural
\cf10 Horizontal (the first switch off non-madantory parent (when such parent is not gene, and the path from it to the target has no gene) of a given gene and such parent's next layer decent gene)\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural
\cf0 \
MAN - next layer decent gene 'required' on it. (if gene and can switch off)\
OPT - do nothing, as itself can control its own existence which has no affect to the other decent gene even if it is gene.\
ALT - same as OPT or MAN or OR, as variability/existence can be represented by root even if it is gene. The chain propagate till root, which is always MAN.\
OR - when it cannot have OR relation, then other next layer decent gene 'at-least-on-required' on it. (if gene, if not, then on its next layer decent gene) Otherwise do nothing as the OR relation ensures existence of the OR group.\
\
OPT, ALT and OR would always be able to be switch off.\
\
(MAN OPT does not need to consider the case of non-gene because their variability can be represented by children directly, while for ALT and OR, their children can only represent their variability after refactoring of dependency)\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural
\cf10 Vertical\cf0 \
\
Go down the tree from for each branch, ONLY NEED TO WORK ON THE NEXT LAYER (all gene as well as their children can be switch off except the Mandatory (depends))\
\
Optional - (if it is a gene) get all its children gene should be dependent of it.\
***Extraction - When dependent, the (can switch off and not under OR group) mandatory child gene ) we set "same_required" dependency, if the current parent gene is the first switch off non-mandatory  parent of that child. i.e., the path from such to the gene are all mandatory or cannot be switch off***\
\
ALT -  if not gene, all its children gene should be dependent of its parent, it also have same_required (selection-to-existence and (existence-to-selection, this is subject to ***Extraction)) dependency. If gene, itself depends on parent (selection-to-existence and existence-to-selection) , its next layer children depends on itself ((existence-to-existence , one or two ways) ).\
***Extraction - When dependent, the (can switch off and not under OR group) mandatory child gene ) we set "same_required" dependency, if the current parent gene is the first switch off non-mandatory  parent of that child. i.e., the path from such to the gene are all mandatory or cannot be switch off***\
\
Mandatory - (if it is a gene and it can switch off) then its children and all genes that share the same first parent, which can be switch off and non-mandatory , should be dependent of it, \cf5 itself also be deponent of the others. \cf0 (unless the first switch off non-mandatory parent is a gene) (due to rule 1, 2)\
***Extraction - When dependent (children or\cf8  \cf5 the dependents are OR group, whose root is the first switch off feature, then the mandatory one would have at-least-one-required dependency to OR group members)\cf0 , the (can switch off and not under OR group) mandatory child gene ) we set "same_required" dependency, if the current parent gene is the first switch off non-mandatory  parent of that child. i.e., the path from such to the gene are all mandatory or cannot be switch off***\
\
\
OR's children -, regardless if OR feature is gene, all OR group genes (and children genes) should have dependency (unless root of OR feature is optional and is not gene and the root is not the first switch off non-mandatory parent of any other mandatory children gene., \cf9 or if it is mandatory can be switch off then itself and its first \cf0 switch off non-mandatory \cf9 parent is not a gene and such parent \cf0 is not the first switch off non-mandatory parent of any other mandatory children gene\cf9 , otherwise it means that itself cannot control its existence. This is need to use together with Extraction and slibing dependency of Mandatory gene\cf0 ), sibling decenor of the same children of OR parent do not need such, but each of them need one for other OR member's   sibling decenor.\
\
Also, when the OR relation does not hold (because the root is optional or conditionally optional, means their variability can not be represented via the others and some direct dependency to them is needed), the other decent gene of the root's first switch off non mandatory feature (or can be itself if it is optional), need to have at-least-one-required to group member.\
\
if OR member's are not gene, then do nothing.\
\
every OR member's (if gene) children should depends on it. ***Extraction - When dependent, the (can switch off and not under OR group) mandatory child gene ) we set "same_required" dependency, if the current parent gene is the first switch off non-mandatory  parent of that child. i.e., the path from such to the gene are all mandatory or cannot be switch off***\
\
\
It is possible to see maintain dependency for OR group member without a central parent.\
\
(OR group can be directly use when it is dependent, when it is main, need special treatment) use union when it involve OR group! This is used when the OR group is main (except 'excluded') and itself cannot be siwthcoff, when the OR group is dependent, simply see as each group member as dependent.\
\
since numeric dependency does not concern existence, it has no effect on the at-least-one logic of OR group. when required, the OR group needs to be union, \
\
(while when excluded, the OR group needs to be intersected, simply as other excluded relation. \cf7 we can actually reverse the dependency in excluded thus it does not need special treatment) (because it mutation and cross over, the checking is double way!)\cf0 \
=============\
\
\
-cross branch dependency\
\
category to category dependency require/exclude\
category to numeric dependency l,r < > = with/without a numeric value: the numeric side has to be on parent. (if use those, it has to be on numeric parent, if based on it, it needs to use l,r)\
numeric to numeric dependency l,r < > = with/without a numeric value: has to have at least one side on parent. (if use those, it has to be on numeric parent, if based on it, it needs to use l,r)\
\
=============\
\
\
When they are remove mean they are not numeric and in a numeric dependency!\
\
DEPENDENT\
\
if dependent is parent, it then find gene by going down next layer, if it cannot go down find gene then it means the dependency can be removed.\
\
If for dependent, if the dependent is the leaf (this can not be numeric feature as it cannot be leaf) ,  then we move up one as the variability is represented by ALT on a parent. this is because\
1. the relation cannot be mandorty as this would make the dependency pointless.\
2. the relation cannot be optional as this would make the main as gene\
3. the relation cannot be in OR group  as this would make the main as gene\
4. it can only be in ALT group thus the parent will definitely the gene.\
\
MAIN \
\
if main is parent, it then find gene by going down next layer, if it cannot go down find gene then it means the dependency can be removed. \
\
need to consider 'required' when main in OR group\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural
\cf11 It should be noted that in cross dependency where the main is parent (include the category-numeric dependency) where the main can be switch off (or it is numeric), only the dependent one is possible to be removed due to Grow 5. (We assume that when required cross dependency, it has been checked that the main one can be switch off, otherwise there is no point to have such dependency.)\cf0 \
\
If for main, if the main is the leaf, (this can not be numeric feature as it cannot be leaf)  then we move up one as the variability is represented by ALT on a parent. this is because\
1. the relation cannot be mandorty as this would make the dependency pointless.\
2. the relation cannot be optional as this would make the main as gene\
3. the relation cannot be in OR group  as this would make the main as gene\
4. it can only be in ALT group thus the parent will definitely the gene.\
\
\
\
=============\
\
We now have the dependency graphic with redundant dependency.\
\
Some important points about dependency merging:\
\
1. Here, a single dependency between two genes represents the constraint on the dependent gene with respect to the conditions of main gene. The extracted dependencies and their imposed constraints are shown in Table.\
\
2. The constraint imposed by a dependency, according to Table,  can be expressed using a \\textbf\{\\emph\{value tree\}\}, where each leaf is a set of optional values constrained by the corresponding condition in branch, i.e., the selected values of main gene.\
\
\
3.  For a given dependent gene, if it has two or more dependencies with identical main genes, then the leaves of the branches, which represent the same condition, can be combined directly, and such a mergence would be always performed before the others. \
\
\
4. In case the dependencies have different main genes, all branch nodes of a value tree are grafted to each branch node of another, forming new levels for the final value tree, representing the combinatorial condition. Then, for all the value trees of different dependencies, the leaves, whose original branch is on the same path from root to a right-most node, are combined to create the leaf-set. \
\
----------\
given correct FM, in double side numeric dependency and they can be switch off, when (the could happen when required_less and excluded_greater_or_equals operator) the main is switch off and the alrithmic calculation lead to empty set, we then fix a 0 to represent that it can only be switch off (if one can switch off, then both should be able to be switch off otherwise it is a design error)! Unless specify in range-to-range (other empty set cases are design error)\
\
Then merge all dependency with the same main/dependent on the graphic to make a simpler graphic for mutation and crossover. (when value change, transit back to its dependents to check, if fine then stop, if needs change then change it and repeat this process.)\
\
Then union following by intersection on a gene that has more than one dependency to build the value net. (select valid value) (mutation need only deponents while crossover needs both main and dependents)\
\
mutation: when mutate check dependent upon mutate, mutate itself when violation of dependent found, stop when no violations. (the original mutation operator would mutate it regardless if it has been mutated due to dependency violation). Since we assume correct/validated FM, there will be always a state that no violation on dependency, even with closed loop.\
\
crossover: when crossover check itself/dependent when swap, swap main/dependent when violation of itself/dependent found and it has not been swapped, stop when no violations or all has been swapped. (the original crossover operator would swap it only if it has been not been previously swapped due to dependency violation)\
\cf12 \
=============\
Need to ensure every dependency leads to at least one value! \cf4 We also need to check looped (unless it does not involve numeric dependency, as categorical dependency all share 0 )dependency. Normally we should not have one, although it might not cause any issue. if we have, alert the people to check it and ensure that there is an end.\cf12  (we just assume that the closed loop will be checked by existing tool and grantee a correct FM!, because if this happen, then it is likely to be a design error in the model to avoid, e.g.,  dead features, \cf13 unwanted conditionally dead features\cf12  and contradiction on feature dependency, we do not consider conditionally dead as it will consider XOR as design error)\
\
Since the FM is correct, then every single dependency would have a set of values, before intersection.\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural
\cf2 in althematic for, when less-required it can have empty is impossible as this would mean that the main's 0 feature is a dead feature, thus an design error.\cf12 \
\
There is a special case where intersection lead to 0 even with a correct FM, i.e., when other dependency intersect with at-least-one-exist  e.g.,\cf0 , \cf12  , OR group member has other dependent other than at-least-one-exist, it could lead to empty set when all main set to 0. This is not a design error but the fact that the at-least-one-exist is a weak dependency and sometime contradict with the others, and the straight intersection does not aware of it. \cf13 fact they have not considered priority/order,\cf12  if this occurs, we see the other dependency (higher order) has higher priority thus set a 0, as this can be ensured by the siblings or the parent can be conditionally/directly deselected (this can also be directly optional as in such case it is possible to still have an at-least-one-exist dependency ). This still complain with the logic.  \cf13 as the lower order dependency would be pointless to ensure if the higher order one is violated. \cf12 Because in a correct FM, . For OR group, if all the member has such dependency (or different ones), then the dependency should be at their parent level. Otherwise, it is fine to set 0 as even if the at-least-one-exist of such member is violated, it can be enforced by other member due to the looped dependency chain.  Both case using the other dependency as higher priority preserve the same logic.\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural
\cf14 (it is impossible to have a case where each OR group member independently required different feature and the root cannot be switch off, as this is a design error: unwanted conditionally dead feature) (this is the same as all member required the same feature)\cf12 \
\
(For ALT and OR parent, we cannot have all their children can be switch off while not themselves (neither directly or conditionally), as this is the same as a MAN required another optional, which is false option design error)\
\
(they should be able to switch off as they have required/exclude relation)\
\
(other cases should be design error, and they should not occur as we assume correct validation on the FM. Also, if the categorical/mathematical comparison of single dependency lead to empty options, this can be a design error as well)\
\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural
\cf0 Some important points about dependency aware operators:\
\
1. For mutation, the requisition ensure that it goes to the depth first.\
\
2. For crossover, the order follows: dependent genes - main genes on one offspring and then do the same to another offspring. It also goes to the depth first. \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural
\cf12 \
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural
\cf15 when a required to deselected (and only, i.e., 0, especially for numeric feature) and other dependency lead to null, then put only 0 (switch off) because it cannot satisfy any both dependency but choose to disable it, in some case, this still represent the valid dependency in the FM, e.g.,:\
\
at-least-one-exist has an extreme case where a OR group member depends on other feature that require itself to deselected, then when the other OR group member are deselected, the intersection leads to null. In such case, we see the other dependency has higher priority (ignore the at-least-one-exist temporarality) as the OR group does not valid if it does not satisfy other dependency.\
\
two cases (same rule apply when multiple other dependency and OR group members):\
\
when all OR group member has other dependency, then it means there is case that OR group can be switch off, thus such solution does not violate. (the key entry feature can be switch off)\
\
when no all OR group member has other dependency, then the group member that does not has extra dependency would enforce the at-least-one-exist, because of OR group in branch enforcement. (the key entry feature can be switch off)\
\
In other case, e..g, c > a and c < b the null would occur when there is possible to have the combination of a > b, then in such case, it is likely to be a design error. (the key entry feature cannot be switch off) (but this should not occur as we assume that the FM is analysed/correct/validated by an existing approach )\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural
\cf12 \
=============\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural
\cf5 other cases would likely to be an error. Extraction - need to ensure intersection is not null (for numeric dependency), \
-----------\cf0 \
\
EXPERIMENTS\
\
(for all other competitors, even with ML based QoS models that are expected to distinguish valid/invalid solution and hoping to guild search properly, this would still wast function evaluation effort and no guarantee the final population would have valid results..) (when we use their alias, we refer to their optimisation part)\
\
our QoS model takes all feature values, even for invalid ones.\
\
for comparing 0/1 (It is unfair to evaluate a model with many dimension of inputs, in function evaluation, we convert them into the representation of QoS model in evaluation. But this need additional method to deal with the dimension mismatching: for XOR use the first 1, if no 1, randomly select one), which will actually help to distinguish valid/invalid solution.  This will actually help to distinguish valid/invalid solution in terns of numeric dependency (search space remain the same)\
\
for DUSE and Plato, since they use manually set representation, we can just set they the same as our representation.\
\
The Fusion one need 0/1and consider categorical dependency in to the exact algorithm, which is naturally allowed to handle dependency constraints.(It is unfair to evaluate a model with many dimension of inputs, , in function evaluation,  we convert them into the representation of QoS model in evaluation, ). This is directly possible without other strategy as categorical dependency, i.e., XOR, has been ensured. This will actually help to distinguish valid/invalid solution in terns of numeric dependency (search space remain the same)\
\
We filter/correct dependency first and then non-dominated ranking and then the requirement. So for population based one, the final would grantee to be valid if the final population contains value.\
\
\
-dependency can be also related to another numeric dependency, e.g., max connection <= max thread if one connection per thread mode is chosen. This differ the case where a dependency is placed between connection and mode, as the former represent if the mode is not chosen, then the numeric dependency does not exist; the latter means if it is not chosen, then connection can not be chosen either.\
\
\cf5 if the leaf has dependency then it move to the dependency of its parent, which is a gen. (this is impossible to occur)\cf0 \
\
the final dependency is an intersection of the dependency for more than one main features.\
\
\pard\tx220\tx720\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\li720\fi-720\pardirnatural
\ls1\ilvl0\cf0 {\listtext	\'95	}Software stack vs. software\
\pard\tx220\tx720\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\li720\fi-720\pardirnatural
\ls2\ilvl0\cf0 {\listtext	\'95	}fine-grained configurations (both numeric and categorical feature) vs. coarse-grained. \
{\listtext	\'95	}design EMO based on feature model. (representation of individual, 0/1 representation cause larger overhead and difficult to handle dependency.Therefore, we need shorter representation that still preserve\cf2  variability of the software\cf0 ). Others needs complex manual analysis.\
{\listtext	\'95	}consider logical dependency, so proactively avoid the wrong values vs. find the values then evaluate using constraint functions. (categorical (on categorical feature) and numeric  (on numeric feature) dependency). 
\b numeric dependency
\b0  could be between numeric features or between numeric and categorical features. (dependency in mutation and crossover)\
{\listtext	\'95	}better optimisation algorithm vs. NSGA-II.\
{\listtext	\'95	}find keen points vs. find pareto front.\
{\listtext	\'95	}exact algorithm's assumption about linear model, convex problem make them difficult to find optimal result in our problem; or they may take a very long time to do so.\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural
\cf0 \
When mutation, change with dependency and check all the dependent variables are correct, if not change it. Do the same for every change.\
\
When crossover, check all the dependent variables are correct, if not, swap it. Do the same for every change.\
\
when not consider dependency, the result need to ensure at least the software is funciontaly correct, e.g., no exception is thrown.\
\
Challenges:\
\
dynamic and uncertainty\
large search space\
\
no systematic design of individuals \
no systematic projection of dependency to mutation and crossover]\
\
the above two means no systematic and automatic approach to translate to SAS problem to MOEA/EA\
\
no knee point, need to pick one form pareto front.\
\
use numerical control variables and categorical control variables\
\
\
if the requirements are too good, can make search difficult which in turn trigger many adaptaions.\
If the requirements are too bad, can not provide enough pressure to search which in turn lead to the scenario where the requirements are always satisfied but it is far away from optimal (cf. compare with an search without requirements)\
\
requirements can have two ways in optimisation (not constraints satisfaction): 1) as weights 2) as constraints\
\
We set the environmental variables as one interval behead, so that the models have a limited look ahead ability (the can be beneficial, e.g., workload becomes larger and larger, or it becomes larger and then smaller). Otherwise, the model would have to assume that the future workload is the same (or similar) as current one, which is unrealistic some time as the environments changes even during decision making process. \
\
When the cost is price related to provision, we still need to use demand for training semi-control knobs otherwise incorrect adaptation decision might be used as samples. Then in prediction, the predicted value becomes a worst bound. This is aim for learning the true correlation.\
\
When the cost is energy related to the actual usage, we can use provision for training as only the actual energy consumption matters.\
\
======================\
\
3. static optimizations (need short and efficient) vs. continuous dynamic optimisation (might be able to tolerate longer running time)\
4. optimisation at the meta-level of self-adaptive system, i.e., switch on/off components\
\
\pard\pardeftab720

\f1 \cf0 gromit\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural

\f0 \cf0 wallace\
\
5.4+7.5=13\
\
6649\
35018\
\
6881-6758\
35279-35145\
}